###
#  Author: Cory M. Simon (CoryMSimon@gmail.com)
###
include("framework.jl")
include("forcefield.jl")

function Buckingham(r, A, B, C)
    """
    Returns energy via a Buckingham potential
    """
    return A * exp( - B  * r) - C / r ^ 6.0
end

function LJ(r, eps, sig)
    """
    Returns energy via a LJ potential
    """
    sig_ovr_r6 = (sig / r) ^ 6.0 
    return 4.0 * eps * sig_ovr_r6 * (sig_ovr_r6 - 1.0)
end

function MOF74_energy(xyz_coord::Array{Float64},
                         framework::Framework,
                         rep_factors::Array{Int},
                         cutoff::Float64)
    """
    Compute Van der Waals interaction energy via the LJ potential of a bead at xyz_coord (Cartesian!)
    
    :param Array{Float64} xyz_coord: Cartesian coordinate of bead. shape: (3,)
    :param Array{Float64} epsilons: Lennard-Jones epsilon parameters for bead with corresponding framework atoms. shape: (framework.natoms,)
    :param Array{Float64} sigmas: Lennard-Jones sigma parameters for bead with corresponding framework atoms. shape: (framework.natoms,)
    :param Framework framework: the structure
    :param Array{Int} rep_factors: x,y,z replication factors of primitive unit cell for PBCs
    :param Float64 cutoff: Lennard-Jones cutoff distance
    """
    @assert(size(xyz_coord) == (3,))

    E = 0.0  # initialize energy of this bead as 0 to subsequently add pairwise contributions
    # loop over adjacent unit cells to implement periodic boundary conditions
    for rep_x = -rep_factors[1]:rep_factors[1]
        for rep_y = -rep_factors[2]:rep_factors[2]
            for rep_z = -rep_factors[3]:rep_factors[3]
                for i = 1:framework.natoms
                    xf_framework = framework.fractional_coords[:, i] + 1.0 * [rep_x, rep_y, rep_z]
                    x_framework = framework.cartesian_to_f_mtrx * xf_framework
                    
                    r = sqrt(dot(x_framework, xyz_coord))

                    if framework.atoms[i] == "H"
                        # use LJ for H
                        E += LJ(r, )
                    else
                        # use Buckingham for others
                        E += Buckingham(r, )
                    end
                end
            end  # end replication in x-direction
        end  # end replication in y-direction
    end  # end replication in z-direction

    return E
end

structurename = "IRMOF-1" 
gridspacing = 0.1  # A
cutoff = 12.5  # A, LJ cutoff

@printf("Constructing framework object for %s...\n", structurename)
framework = Framework(structurename)
    
# get unit cell replication factors for periodic BCs
rep_factors = get_replication_factors(framework.f_to_cartesian_mtrx, cutoff)
@printf("Unit cell replication factors for LJ cutoff of %.2f A: %d by %d by %d\n", cutoff, rep_factors[1], rep_factors[2], rep_factors[3])

# how many grid points in each direction? 
N_x = int(framework.a / gridspacing) + 1
N_y = int(framework.b / gridspacing) + 1
N_z = int(framework.c / gridspacing) + 1
@printf("Grid is %d by %d by %d points, a total of %d grid points.\n", N_x, N_y, N_z, N_x*N_y*N_z)
# fractional grid point spacing. Think of grid points as center of voxels.
dx_f = 1.0 / (N_x - 1)
dy_f = 1.0 / (N_y - 1)
dz_f = 1.0 / (N_z - 1)
@printf("Fractional grid spacing: dx_f = %f, dy_f = %f, dz_f = %f\n", dx_f, dy_f, dz_f)

# get fractional coords of energy grid. 
xf_grid = linspace(0.0, 1.0, N_x)
yf_grid = linspace(0.0, 1.0, N_y)
zf_grid = linspace(0.0, 1.0, N_z)

# get grid point spacing in Cartesian space, just for kicks ^.^
cartesian_spacing = framework.f_to_cartesian_mtrx * [xf_grid[2]-xf_grid[1], yf_grid[2]-yf_grid[1], zf_grid[2]-zf_grid[1]]
@printf("Grid spacing: dx = %.2f, dy = %.2f, dz = %.2f\n", cartesian_spacing[1], cartesian_spacing[2], cartesian_spacing[3])

# open grid file
if ! isdir(homedir() * "/PEGrid_output/" * forcefieldname)
   mkdir(homedir() * "/PEGrid_output/" * forcefieldname)
end
gridfilename = homedir() * "/PEGrid_output/" * forcefieldname * "/" * framework.structurename * "_" * adsorbatename * ".cube"
gridfile = open(gridfilename, "w")

# Format of .cube described here http://paulbourke.net/dataformats/cube/
write(gridfile, "This is a grid file generated by PEviz\nLoop order: x, y, z\n")
@printf(gridfile, "%d %f %f %f\n" , 0, 0.0, 0.0, 0.0)  # 0 atoms, then origin
# TODO list atoms in the crystal structure
@printf(gridfile, "%d %f %f %f\n" , N_x, framework.f_to_cartesian_mtrx[1,1] / (N_x - 1), 0.0, 0.0)  # N_x, vector along x-edge of voxel
@printf(gridfile, "%d %f %f %f\n" , N_y, framework.f_to_cartesian_mtrx[1,2] / (N_y - 1), framework.f_to_cartesian_mtrx[2,2] / (N_y - 1), 0.0)  # N_y, vector along y-edge of voxel
@printf(gridfile, "%d %f %f %f\n" , N_z, framework.f_to_cartesian_mtrx[1,3] / (N_z - 1), framework.f_to_cartesian_mtrx[2,3] / (N_z - 1), framework.f_to_cartesian_mtrx[3,3] / (N_z - 1))

@printf("Writing grid...\n")
# loop over [fractional] grid points, compute energies
for i in 1:N_x  # loop over x_f-grid points
    # print progress
    if i % (int(N_x/10.0)) == 0
        @printf("\tPercent finished: %.1f\n", 100.0*i/N_x)
    end

    for j in 1:N_y  # loop over y_f-grid points
        for k in 1:N_z  # loop over z_f-grid points
            
            # grid pt
            xyz_coord = framework.f_to_cartesian_mtrx * [xf_grid[i], yf_grid[j], zf_grid[k]]

            E = MOF74_energy(xyz_coord,
                         framework,
                         rep_factors,
                         cutoff)
            
            # write energy at this point to grid file
            @printf(gridfile, "%e ", E * 8.314 / 1000.0)  # store in kJ/mol
            if (k % 6) == 0
                @printf(gridfile, "\n")
            end

        end # end loop in z_f-grid points
        @printf(gridfile, "\n")
    end # end loop in y_f-grid points
end # end loop in x_f-grid points
close(gridfile)
@printf("\tDone.\nGrid available in %s\n", gridfilename)
